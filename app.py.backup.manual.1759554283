#!/usr/bin/env python3
"""
Snake Game implemented with pygame.

Features:
- Robust error handling and detailed logging.
- Clean separation of concerns via classes.
- Main entry point protected by if __name__ == "__main__".
"""

import sys
import random
import logging
from dataclasses import dataclass, field
from typing import List, Tuple

try:
    import pygame
except ImportError as exc:
    print("pygame is required to run this game. Install it via 'pip install pygame'.")
    raise exc

# --------------------------------------------------------------------------- #
# Configuration and Constants
# --------------------------------------------------------------------------- #
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 480
GRID_SIZE = 20
GRID_WIDTH = SCREEN_WIDTH // GRID_SIZE
GRID_HEIGHT = SCREEN_HEIGHT // GRID_SIZE
FPS = 10

# Colors (R, G, B)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
RED = (255, 0, 0)
DARK_GREEN = (0, 155, 0)
DARK_RED = (155, 0, 0)

# --------------------------------------------------------------------------- #
# Logging Setup
# --------------------------------------------------------------------------- #
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

# --------------------------------------------------------------------------- #
# Data Classes
# --------------------------------------------------------------------------- #
@dataclass
class Snake:
    body: List[Tuple[int, int]] = field(default_factory=lambda: [(GRID_WIDTH // 2, GRID_HEIGHT // 2)])
    direction: Tuple[int, int] = (0, -1)  # Initially moving up
    grow_pending: int = 0

    def move(self) -> None:
        """Move the snake in the current direction."""
        head_x, head_y = self.body[0]
        dir_x, dir_y = self.direction
        new_head = (head_x + dir_x, head_y + dir_y)
        self.body.insert(0, new_head)
        if self.grow_pending > 0:
            self.grow_pending -= 1
            logger.debug(f"Snake grew. Remaining grow_pending: {self.grow_pending}")
        else:
            removed = self.body.pop()
            logger.debug(f"Removed tail segment: {removed}")

    def change_direction(self, new_dir: Tuple[int, int]) -> None:
        """Change direction if it's not directly opposite."""
        opposite = (-self.direction[0], -self.direction[1])
        if new_dir != opposite:
            logger.debug(f"Direction changed from {self.direction} to {new_dir}")
            self.direction = new_dir
        else:
            logger.debug(f"Ignored reverse direction change to {new_dir}")

    def grow(self) -> None:
        """Schedule the snake to grow on the next move."""
        self.grow_pending += 1
        logger.info("Snake scheduled to grow.")

    def collides_with_self(self) -> bool:
        """Check if the snake's head collides with its body."""
        head = self.body[0]
        collision = head in self.body[1:]
        if collision:
            logger.info(f"Snake collided with itself at {head}")
        return collision

    def collides_with_wall(self) -> bool:
        """Check if the snake's head collides with the wall."""
        head_x, head_y = self.body[0]
        collision = not (0 <= head_x < GRID_WIDTH and 0 <= head_y < GRID_HEIGHT)
        if collision:
            logger.info(f"Snake collided with wall at {self.body[0]}")
        return collision


@dataclass
class Food:
    position: Tuple[int, int] = (0, 0)

    def spawn(self, snake_body: List[Tuple[int, int]]) -> None:
        """Place food at a random location not occupied by the snake."""
        while True:
            new_pos = (
                random.randint(0, GRID_WIDTH - 1),
                random.randint(0, GRID_HEIGHT - 1),
            )
            if new_pos not in snake_body:
                self.position = new_pos
                logger.info(f"Food spawned at {self.position}")
                break


# --------------------------------------------------------------------------- #
# Game Class
# --------------------------------------------------------------------------- #
class SnakeGame:
    def __init__(self) -> None:
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Snake Game")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont(None, 36)

        self.snake = Snake()
        self.food = Food()
        self.food.spawn(self.snake.body)

        self.score = 0
        self.game_over = False
        logger.info("Game initialized.")

    def reset(self) -> None:
        """Reset the game state."""
        self.snake = Snake()
        self.food.spawn(self.snake.body)
        self.score = 0
        self.game_over = False
        logger.info("Game reset.")

    def handle_events(self) -> None:
        """Process all pending events."""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                logger.info("Quit event received.")
                pygame.quit()
                sys.exit(0)
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    self.snake.change_direction((0, -1))
                elif event.key == pygame.K_DOWN:
                    self.snake.change_direction((0, 1))
                elif event.key == pygame.K_LEFT:
                    self.snake.change_direction((-1, 0))
                elif event.key == pygame.K_RIGHT:
                    self.snake.change_direction((1, 0))
                elif event.key == pygame.K_ESCAPE:
                    logger.info("Escape pressed. Exiting.")
                    pygame.quit()
                    sys.exit(0)
                elif event.key == pygame.K_r and self.game_over:
                    logger.info("Restart requested.")
                    self.reset()

    def update(self) -> None:
        """Update game logic."""
        if self.game_over:
            return

        self.snake.move()

        # Check for collisions
        if self.snake.collides_with_wall() or self.snake.collides_with_self():
            self.game_over = True
            logger.info(f"Game over! Final score: {self.score}")
            return

        # Check if food eaten
        if self.snake.body[0] == self.food.position:
            self.snake.grow()
            self.score += 1
            self.food.spawn(self.snake.body)

    def draw_grid(self) -> None:
        """Draw the background grid."""
        for x in range(0, SCREEN_WIDTH, GRID_SIZE):
            pygame.draw.line(self.screen, DARK_GREEN, (x, 0), (x, SCREEN_HEIGHT))
        for y in range(0, SCREEN_HEIGHT, GRID_SIZE):
            pygame.draw.line(self.screen, DARK_GREEN, (0, y), (SCREEN_WIDTH, y))

    def draw_snake(self) -> None:
        """Render the snake."""
        for segment in self.snake.body:
            rect = pygame.Rect(
                segment[0] * GRID_SIZE,
                segment[1] * GRID_SIZE,
                GRID_SIZE,
                GRID_SIZE,
            )
            pygame.draw.rect(self.screen, GREEN, rect)
            pygame.draw.rect(self.screen, DARK_GREEN, rect, 1)

    def draw_food(self) -> None:
        """Render the food."""
        rect = pygame.Rect(
            self.food.position[0] * GRID_SIZE,
            self.food.position[1] * GRID_SIZE,
            GRID_SIZE,
            GRID_SIZE,
        )
        pygame.draw.rect(self.screen, RED, rect)
        pygame.draw.rect(self.screen, DARK_RED, rect, 1)

    def draw_score(self) -> None:
        """Display the current score."""
        text = self.font.render(f"Score: {self.score}", True, WHITE)
        self.screen.blit(text, (10, 10))

    def draw_game_over(self) -> None:
        """Display game over message."""
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))  # Semi-transparent overlay
        self.screen.blit(overlay, (0, 0))

        msg = self.font.render("Game Over! Press R to Restart or ESC to Quit", True, WHITE)
        rect = msg.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
        self.screen.blit(msg, rect)

    def render(self) -> None:
        """Render all game elements."""
        self.screen.fill(BLACK)
        self.draw_grid()
        self.draw_snake()
        self.draw_food()
        self.draw_score()
        if self.game_over:
            self.draw_game_over()
        pygame.display.flip()

    def run(self) -> None:
        """Main game loop."""
        logger.info("Game loop started.")
        while True:
            try:
                self.handle_events()
                self.update()
                self.render()
                self.clock.tick(FPS)
            except pygame.error as e:
                logger.exception(f"Pygame error: {e}")
                pygame.quit()
                sys.exit(1)
            except KeyboardInterrupt:
                logger.info("KeyboardInterrupt received. Exiting.")
                pygame.quit()
                sys.exit(0)
            except Exception:
                logger.exception("Unexpected error occurred.")
                pygame.quit()
                sys.exit(1)


# --------------------------------------------------------------------------- #
# Entry Point
# --------------------------------------------------------------------------- #
def main() -> None:
    """Entry point for the Snake game."""
    try:
        game = SnakeGame()
        game.run()
    except Exception:
        logger.exception("Fatal error in main.")
        pygame.quit()
        sys.exit(1)


if __name__ == "__main__":
    main()